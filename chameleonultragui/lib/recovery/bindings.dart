// ignore_for_file: always_specify_types
// ignore_for_file: camel_case_types
// ignore_for_file: non_constant_identifier_names

// AUTO GENERATED FILE, DO NOT EDIT.
//
// Generated by `package:ffigen`.
// ignore_for_file: type=lint
import 'dart:ffi' as ffi;

/// Bindings for `src/recovery.h`.
///
/// Regenerate bindings with `flutter pub run ffigen --config ffigen.yaml`.
/// On linux might be needed:
/// export CPATH="$(clang -v 2>&1 | grep "Selected GCC installation" | rev | cut -d' ' -f1 | rev)/include"
///
class Recovery {
  /// Holds the symbol lookup function.
  final ffi.Pointer<T> Function<T extends ffi.NativeType>(String symbolName)
      _lookup;

  /// The symbols are looked up in [dynamicLibrary].
  Recovery(ffi.DynamicLibrary dynamicLibrary) : _lookup = dynamicLibrary.lookup;

  /// The symbols are looked up with [lookup].
  Recovery.fromLookup(
      ffi.Pointer<T> Function<T extends ffi.NativeType>(String symbolName)
          lookup)
      : _lookup = lookup;

  ffi.Pointer<ffi.Uint64> darkside(
    ffi.Pointer<Darkside> data,
    ffi.Pointer<ffi.Uint64> keyCount,
  ) {
    return _darkside(
      data,
      keyCount,
    );
  }

  late final _darksidePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Uint64> Function(
              ffi.Pointer<Darkside>, ffi.Pointer<ffi.Uint64>)>>('darkside');
  late final _darkside = _darksidePtr.asFunction<
      ffi.Pointer<ffi.Uint64> Function(
          ffi.Pointer<Darkside>, ffi.Pointer<ffi.Uint64>)>();

  ffi.Pointer<ffi.Uint64> nested(
    ffi.Pointer<Nested> data,
    ffi.Pointer<ffi.Uint32> keyCount,
  ) {
    return _nested(
      data,
      keyCount,
    );
  }

  late final _nestedPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Uint64> Function(
              ffi.Pointer<Nested>, ffi.Pointer<ffi.Uint32>)>>('nested');
  late final _nested = _nestedPtr.asFunction<
      ffi.Pointer<ffi.Uint64> Function(
          ffi.Pointer<Nested>, ffi.Pointer<ffi.Uint32>)>();

  ffi.Pointer<ffi.Uint64> static_nested(
    ffi.Pointer<StaticNested> data,
    ffi.Pointer<ffi.Uint32> keyCount,
  ) {
    return _static_nested(
      data,
      keyCount,
    );
  }

  late final _static_nestedPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Uint64> Function(ffi.Pointer<StaticNested>,
              ffi.Pointer<ffi.Uint32>)>>('static_nested');
  late final _static_nested = _static_nestedPtr.asFunction<
      ffi.Pointer<ffi.Uint64> Function(
          ffi.Pointer<StaticNested>, ffi.Pointer<ffi.Uint32>)>();

  int mfkey32(
    ffi.Pointer<Mfkey32> data,
  ) {
    return _mfkey32(
      data,
    );
  }

  late final _mfkey32Ptr =
      _lookup<ffi.NativeFunction<ffi.Uint64 Function(ffi.Pointer<Mfkey32>)>>(
          'mfkey32');
  late final _mfkey32 =
      _mfkey32Ptr.asFunction<int Function(ffi.Pointer<Mfkey32>)>();

  int hardnested(
    ffi.Pointer<HardNested> data,
  ) {
    return _hardnested(
      data,
    );
  }

  late final _hardnestedPtr =
      _lookup<ffi.NativeFunction<ffi.Uint64 Function(ffi.Pointer<HardNested>)>>(
          'hardnested');
  late final _hardnested =
      _hardnestedPtr.asFunction<int Function(ffi.Pointer<HardNested>)>();
}

final class DarksideItem extends ffi.Struct {
  @ffi.Uint32()
  external int nt1;

  @ffi.Uint64()
  external int ks1;

  @ffi.Uint64()
  external int par;

  @ffi.Uint32()
  external int nr;

  @ffi.Uint32()
  external int ar;
}

final class Darkside extends ffi.Struct {
  @ffi.Uint32()
  external int uid;

  external ffi.Pointer<DarksideItem> items;

  @ffi.Uint32()
  external int count;
}

final class Nested extends ffi.Struct {
  @ffi.Uint32()
  external int uid;

  @ffi.Uint32()
  external int dist;

  @ffi.Uint32()
  external int nt0;

  @ffi.Uint32()
  external int nt0_enc;

  @ffi.Uint32()
  external int par0;

  @ffi.Uint32()
  external int nt1;

  @ffi.Uint32()
  external int nt1_enc;

  @ffi.Uint32()
  external int par1;
}

final class StaticNested extends ffi.Struct {
  @ffi.Uint32()
  external int uid;

  @ffi.Uint32()
  external int key_type;

  @ffi.Uint32()
  external int nt0;

  @ffi.Uint32()
  external int nt0_enc;

  @ffi.Uint32()
  external int nt1;

  @ffi.Uint32()
  external int nt1_enc;
}

final class Mfkey32 extends ffi.Struct {
  /// serial number
  @ffi.Uint32()
  external int uid;

  /// tag challenge first
  @ffi.Uint32()
  external int nt0;

  /// tag challenge second
  @ffi.Uint32()
  external int nt1;

  /// first encrypted reader challenge
  @ffi.Uint32()
  external int nr0_enc;

  /// first encrypted reader response
  @ffi.Uint32()
  external int ar0_enc;

  /// second encrypted reader challenge
  @ffi.Uint32()
  external int nr1_enc;

  /// second encrypted reader response
  @ffi.Uint32()
  external int ar1_enc;
}

final class HardNested extends ffi.Struct {
  external ffi.Pointer<ffi.Char> nonces;

  @ffi.Uint32()
  external int length;
}
